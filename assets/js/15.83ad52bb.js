(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{414:function(e,v,a){e.exports=a.p+"assets/img/image-20210202221029440.debb7132.png"},415:function(e,v,a){e.exports=a.p+"assets/img/jsgct_dt_004_grbg_frst_hp.efdc1cd9.png"},461:function(e,v,a){"use strict";a.r(v);var _=a(13),t=Object(_.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[e._v("#")]),e._v(" 垃圾收集器")]),e._v(" "),_("p",[e._v("常见的垃圾收集器有三种：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("串行收集器 Serial：Serial、Serial Old")])]),e._v(" "),_("li",[_("p",[e._v("并行收集器 Parallel：Parallel Scavenge、Parallel Old 以吞吐量优先")])]),e._v(" "),_("li",[_("p",[e._v("并发收集器 Concurrent：")]),e._v(" "),_("ul",[_("li",[e._v("CMS")]),e._v(" "),_("li",[e._v("G1")])]),e._v(" "),_("p",[e._v("停顿时间优先，也就是响应时间有限")])])]),e._v(" "),_("h2",{attrs:{id:"串行收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串行收集器"}},[e._v("#")]),e._v(" 串行收集器")]),e._v(" "),_("p",[e._v("单线程的，发现 jvm 内存不够用，暂停应用程序的执行，执行垃圾回收，回收完成之后，再继续执行应用程序")]),e._v(" "),_("p",[e._v("主要用于嵌入式的小型内存场景中。")]),e._v(" "),_("h2",{attrs:{id:"并行-vs-并发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行-vs-并发"}},[e._v("#")]),e._v(" 并行 VS 并发")]),e._v(" "),_("p",[e._v("垃圾收集器中的并行并发并不是平时高并发中的并发。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("并行（Parallel）")]),e._v(" "),_("p",[e._v("指多条垃圾收集线程并行工作，但此时 "),_("strong",[e._v("用户线程仍然处于等待状态")]),e._v("。")]),e._v(" "),_("p",[e._v("适合科学计算、后台处理等弱交互场景。")])]),e._v(" "),_("li",[_("p",[e._v("并发（Concurrent）")]),e._v(" "),_("p",[e._v("指用户线程与垃圾收集器线程同时执行（但不定是并行的，可能会交替执行），垃圾收集线程在执行的时候不会停顿用户程序的运行。")]),e._v(" "),_("p",[e._v("适合对响应时间有要求的场景，比如 Web")])])]),e._v(" "),_("h2",{attrs:{id:"停顿时间-vs-吞吐量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#停顿时间-vs-吞吐量"}},[e._v("#")]),e._v(" 停顿时间 VS 吞吐量")]),e._v(" "),_("p",[e._v("垃圾收集器中的吞吐量也不是平时高并发中的吞吐量")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("停顿时间")]),e._v(" "),_("p",[e._v("垃圾收集器做垃圾回收中断应用执行的时间。 "),_("code",[e._v("-XX:MaxGCPauseMillis")])])]),e._v(" "),_("li",[_("p",[e._v("吞吐量")]),e._v(" "),_("p",[e._v("花在 "),_("strong",[e._v("垃圾收集")]),e._v(" 的时间和花在 "),_("strong",[e._v("应用时间")]),e._v(" 的占比。")]),e._v(" "),_("p",[_("code",[e._v("-XX:GCTimeRatio=<n>")]),e._v("，垃圾收集时间占 "),_("code",[e._v("1/1 + n")])])])]),e._v(" "),_("p",[e._v("评判一个垃圾收集器的好坏：在吞吐量最佳的时候，停顿时间最少。但是在现实中，这两个指标很难同时做到都优秀，一般都是互斥的。")]),e._v(" "),_("h2",{attrs:{id:"串行收集器-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#串行收集器-2"}},[e._v("#")]),e._v(" 串行收集器")]),e._v(" "),_("p",[e._v("开启串行收集器：")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("-XX:+UseSerialGC")]),e._v("：这个是对新生代开启串行，但是会将老生代默认启用下面的参数，也就是老生代的串行 GC")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:+UseSerialOldGC")])])])]),e._v(" "),_("h2",{attrs:{id:"并行收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并行收集器"}},[e._v("#")]),e._v(" 并行收集器")]),e._v(" "),_("p",[e._v("它是以 "),_("strong",[e._v("吞吐量优先")]),e._v(" 的垃圾收集器，开启方式：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-XX:+UseParallelGC")])]),e._v(" "),_("li",[_("code",[e._v("-XX:+UseParallelOldGC")])])]),e._v(" "),_("p",[e._v("该收集器在 Server 模式下是默认的收集器。")]),e._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[e._v("什么是 Server 模式？")]),e._v(" "),_("p",[e._v("jvm 会根据当前机器的配置判定开启 server 模式还是 client 模式，一般来说，机器内存大于 2G，就会启用 server 模式")])]),e._v(" "),_("p",[e._v("下面可以来看下我们启动的应用程序默认启用的垃圾收集器")]),e._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[e._v("mrcode@mrcode ~ % jps -l\n"),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("20572")]),e._v(" org.gradle.launcher.daemon.bootstrap.GradleDaemon\n"),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("20575")]),e._v(" cn.mrcode.stady.monitor_tuning.MonitorTuningApplication\n\nmrcode@mrcode ~ % jinfo -flag UseParallelGC "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("20575")]),e._v("\n-XX:+UseParallelGC\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br"),_("span",{staticClass:"line-number"},[e._v("6")]),_("br")])]),_("h2",{attrs:{id:"并发收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发收集器"}},[e._v("#")]),e._v(" 并发收集器")]),e._v(" "),_("p",[e._v("是以响应时间有限的垃圾收集器。在 JDK 中有两种并行的收集器，开启方法如下：")]),e._v(" "),_("h3",{attrs:{id:"cms"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms"}},[e._v("#")]),e._v(" CMS")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("-XX:+UseConcMarkSweepGC")])])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:+UseParNewGC")])])])]),e._v(" "),_("div",{staticClass:"language-bash line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-bash"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 首先看现在的应用，该收集器并没有开启")]),e._v("\nmrcode@mrcode ~ % jinfo -flag UseConcMarkSweepGC "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("20575")]),e._v(" \n-XX:-UseConcMarkSweepGC\n\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 添加启动参数，并重启程序后，再次观察")]),e._v("\nmrcode@mrcode ~ % jinfo -flag UseConcMarkSweepGC "),_("span",{pre:!0,attrs:{class:"token number"}},[e._v("20801")]),e._v("\n-XX:+UseConcMarkSweepGC\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br"),_("span",{staticClass:"line-number"},[e._v("3")]),_("br"),_("span",{staticClass:"line-number"},[e._v("4")]),_("br"),_("span",{staticClass:"line-number"},[e._v("5")]),_("br"),_("span",{staticClass:"line-number"},[e._v("6")]),_("br"),_("span",{staticClass:"line-number"},[e._v("7")]),_("br")])]),_("h3",{attrs:{id:"g1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1"}},[e._v("#")]),e._v(" G1")]),e._v(" "),_("p",[e._v("开启方式："),_("code",[e._v("-XX:+UseG1GC")])]),e._v(" "),_("h2",{attrs:{id:"垃圾收集器搭配"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器搭配"}},[e._v("#")]),e._v(" 垃圾收集器搭配")]),e._v(" "),_("p",[e._v("在不同的区里面使用的垃圾收集器不同，前面讲过，JDK 使用的是分代垃圾回收方式")]),e._v(" "),_("p",[_("img",{attrs:{src:a(414),alt:"image-20210202221029440"}})]),e._v(" "),_("p",[e._v("两个区里面的收集器不一样，但是上线有连线的是成对搭配使用的。在 JDK8+ 中，建议使用 G1 收集器，性能较高")]),e._v(" "),_("p",[e._v("其中虚线是在某些情况下，CMS 会退化成 SerialOld 收集器。我们课程的终点是  G1 收集器。")]),e._v(" "),_("h2",{attrs:{id:"如何选择垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何选择垃圾收集器"}},[e._v("#")]),e._v(" 如何选择垃圾收集器")]),e._v(" "),_("p",[e._v("一般有如下建议：")]),e._v(" "),_("ul",[_("li",[e._v("优先调整堆的大小，让服务器自己来选择")]),e._v(" "),_("li",[e._v("如果内存小于 100M，使用串行收集器")]),e._v(" "),_("li",[e._v("如果是单核，并且没有停顿时间的要求，串行或则 JVM 自己选择")]),e._v(" "),_("li",[e._v("如果允许停顿时间超过 1 秒，选择并行或则 JVM 自己选择")]),e._v(" "),_("li",[e._v("如果响应时间最重要，并且不能超过 1 秒，使用并发收集器")])]),e._v(" "),_("p",[e._v("官方文档中有讲解，在 "),_("a",{attrs:{href:"https://docs.oracle.com/javase/8/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JDK8"),_("OutboundLink")],1),e._v(" 页面中的 "),_("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning",target:"_blank",rel:"noopener noreferrer"}},[_("strong",[e._v("HotSpot Virtual Machine Garbage Collection Tuning Guide")]),_("OutboundLink")],1),e._v(" 中，专门讲解如何进行 GC 调优。非常详细")]),e._v(" "),_("h2",{attrs:{id:"parallel-collector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#parallel-collector"}},[e._v("#")]),e._v(" Parallel Collector")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("-XX:+UseParallelGC")]),e._v("  手动开启")]),e._v(" "),_("p",[e._v("Server 模式默认开启")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:ParallelGCThreads=<N>")]),e._v(" 使用 n 个 GC 线程")]),e._v(" "),_("p",[e._v("默认 n 为以下计算方式：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("CPU > 8")]),e._v("："),_("code",[e._v("N=5/8")])]),e._v(" "),_("li",[_("code",[e._v("CPU < 8")]),e._v("："),_("code",[e._v("N=CPU")])])])])]),e._v(" "),_("p",[e._v("垃圾收集器有一个自适应功能（Ergonomics），比如设置以下三个参数：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-XX:MaxGCPauseMillis=<N>")])]),e._v(" "),_("li",[_("code",[e._v("-xx:GCTimeRatio=<N>")])]),e._v(" "),_("li",[_("code",[e._v("-Xmx<N>")])])]),e._v(" "),_("p",[e._v("它会按照顺序平衡前两个。也就是会进行动态的调整各个区的大小")]),e._v(" "),_("h3",{attrs:{id:"动态内存调整"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#动态内存调整"}},[e._v("#")]),e._v(" 动态内存调整")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("-XX:YoungGenerationSizelncrement=<Y>")]),e._v("：增加 Young 区内存大小，默认值为 20%")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:TenuredGenerationSizelncrement=<Y>")]),e._v("：增加 Old 区内存大小，默认值为 20%")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:AdaptiveSizeDecrementScaleFactor=<Y>")]),e._v("：：减少内存大小，默认值为 4%")])])]),e._v(" "),_("h2",{attrs:{id:"cms-collector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms-collector"}},[e._v("#")]),e._v(" CMS Collector")]),e._v(" "),_("p",[e._v("它是一个 "),_("strong",[e._v("并发收集")]),e._v("，低停顿、低延迟，是一个老年代收集器")]),e._v(" "),_("h3",{attrs:{id:"cms-垃圾收集过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms-垃圾收集过程"}},[e._v("#")]),e._v(" CMS 垃圾收集过程")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("CMS initial mark：初始标记 Root，STW （停止应用程序）")])]),e._v(" "),_("li",[_("p",[e._v("CMS concurrent mark：并发标记")])]),e._v(" "),_("li",[_("p",[e._v("CMS-concurrent-preclean：并发预清理")])]),e._v(" "),_("li",[_("p",[e._v("CMS remark：重新标记，STW（停止应用程序）")]),e._v(" "),_("p",[e._v("此时应用程序还在运行，有可能又有垃圾了，所以重新标记")])]),e._v(" "),_("li",[_("p",[e._v("CMS concurrent sweep：并发清除")])]),e._v(" "),_("li",[_("p",[e._v("CMS concurrent reset：并发重置")])])]),e._v(" "),_("h3",{attrs:{id:"cms-缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms-缺点"}},[e._v("#")]),e._v(" CMS 缺点")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("CPU 敏感")]),e._v(" "),_("p",[e._v("比如设置一个并发线程，那么只有双核的时候，垃圾收集器就会占用其中一个，这个时候就只有一个核心为应用工作了")])]),e._v(" "),_("li",[_("p",[e._v("浮动垃圾：会产生浮动垃圾")]),e._v(" "),_("p",[e._v("因为程序还在运行，一边回收，一边分配，就会产生浮动垃圾")])]),e._v(" "),_("li",[_("p",[e._v("空间碎片")])])]),e._v(" "),_("h3",{attrs:{id:"cms-的相关参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cms-的相关参数"}},[e._v("#")]),e._v(" CMS 的相关参数")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("-XX:ConcGCThreads")]),e._v("：并发的 GC 线程数")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:+UseCMSCompactAtFullCollection")]),e._v("：FullGC 之后做压缩")]),e._v(" "),_("p",[e._v("上面说会产生碎片，所内存压缩就相当于在清除空间碎片")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:CMSFullGCsBeforeCompaction")]),e._v("：多少次 FUllGC 之后压缩一次")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:CMSInitiatingOccupancyFraction")]),e._v("：触发 FullGC")]),e._v(" "),_("p",[e._v("Old 区在填满多少存活对象的时候触发一次 FullGC，该值默认值应该是 90%+")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:+UseCMSInitatingOccupancyOnly")]),e._v("：是否动态调整")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:+CMSScavengeBeforeRemark")]),e._v("：FullGC 之前先做 YGC")]),e._v(" "),_("p",[e._v("因为在 YGC 之后，会回收一部分垃圾，再做 Old GC 的时候就会减少很多工作。")]),e._v(" "),_("p",[e._v("笔者疑问：但是不是说是分代垃圾回收吗？怎么还会跨区影响？")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("-XX:CMSClassUnloadingEnabled")]),e._v("：启用回收 Perm 区")]),e._v(" "),_("p",[e._v("JDK7 以前有该区")])])]),e._v(" "),_("p",[e._v("如果没有设置，显示 -1，在文档中有说明它的默认值是多少。")]),e._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("mrcode@mrcode ~ % jinfo -flag CMSInitiatingOccupancyFraction 20572 \n-XX:CMSInitiatingOccupancyFraction=-1\n")])]),e._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[e._v("1")]),_("br"),_("span",{staticClass:"line-number"},[e._v("2")]),_("br")])]),_("p",[e._v("CMS 还有一个 iCMS，适用于单核或则双核，因为核数少时，垃圾比较多，回收一次占用时间过长，就会影响应用程序，iCMS 就是为了优化这一点，分多次回收。")]),e._v(" "),_("h2",{attrs:{id:"g1-collector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1-collector"}},[e._v("#")]),e._v(" G1 Collector")]),e._v(" "),_("p",[e._v("JDK8 中支持的垃圾回收器，不断的在进化，在 JDK11 中又有了其他的垃圾回收器")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection",target:"_blank",rel:"noopener noreferrer"}},[e._v("Garbage-First（G1）"),_("OutboundLink")],1),e._v(" 垃圾收集器是一种服务器样式的垃圾收集器，适用于具有大内存的多处理器计算机。它试图以高概率满足垃圾收集（GC）暂停时间目标，同时实现高吞吐量。全堆操作（例如全局标记）与应用程序线程同时执行。这样可以防止与堆或活动数据大小成比例的中断。")]),e._v(" "),_("p",[e._v("G1 收集器通过多种技术实现了高性能和暂停时间目标。")]),e._v(" "),_("p",[e._v("G1 的首要重点是为运行需要大堆且 GC 延迟有限的应用程序的用户提供解决方案。这意味着堆大小约为 6 GB 或更大，并且稳定且可预测的暂停时间低于 0.5 秒。")]),e._v(" "),_("p",[e._v("它同时是新生代和老生代收集器")]),e._v(" "),_("p",[_("img",{attrs:{src:a(415),alt:"如下图9-1所示"}})]),e._v(" "),_("p",[e._v("它是将堆划分成一块一块的，在逻辑上某些块组成了各种数据区，比如 Old 区。")]),e._v(" "),_("h3",{attrs:{id:"g1-的概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1-的概念"}},[e._v("#")]),e._v(" G1 的概念")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("Region：比如上图中的 H，几个块组成的一个区")])]),e._v(" "),_("li",[_("p",[e._v("SATB：Snapshot-At-The-Beginning")]),e._v(" "),_("p",[e._v("它是通过 Root Tracing 得到的，GC 开始时候存活对象的快照，后面再做垃圾回收的时候，会以此基础作为回收")])]),e._v(" "),_("li",[_("p",[e._v("Rset：记录了其他 Region 中的对应引用本 Region 中对象的关系，属于 points-into 结构（谁引用了我的对象）")])])]),e._v(" "),_("h3",{attrs:{id:"younggc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#younggc"}},[e._v("#")]),e._v(" YoungGC")]),e._v(" "),_("ul",[_("li",[e._v("新对象进入 Eden 区")]),e._v(" "),_("li",[e._v("存活对象拷贝到 Survivor 区")]),e._v(" "),_("li",[e._v("存活时间到达年龄阈值时，对象晋升到 Old 区")])]),e._v(" "),_("h3",{attrs:{id:"mixedgc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mixedgc"}},[e._v("#")]),e._v(" MixedGC")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("回收所有的 Young 和 "),_("strong",[e._v("部分 Old")]),e._v("，所以不是 FullGC")]),e._v(" "),_("p",[e._v("这一部分可以通过某些参数设置")])]),e._v(" "),_("li",[_("p",[e._v("global concurrent marking：全局并发标记")]),e._v(" "),_("ol",[_("li",[e._v("Initial marking phase：标记 GC Root，STW")]),e._v(" "),_("li",[e._v("Root region scanning phase：标记存活 Region")]),e._v(" "),_("li",[e._v("Concurrent marking phase：标记存活的对象")]),e._v(" "),_("li",[e._v("Remark phase：重新标记，STW")]),e._v(" "),_("li",[e._v("Cleanup phase：部分 STW")])])]),e._v(" "),_("li",[_("p",[e._v("MixedGC 时机，通过以下参数控制")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("InitiatingHeapOccupancyPercent")]),e._v("：堆占有率达到这个数值则触发 global concurrent marking ，默认 45%")]),e._v(" "),_("li",[_("code",[e._v("G1HeapWastePercent")]),e._v("：在 global concurrent marking 结束之后，可以知道区有多少空间要被回收，在每次 YGC 之后和再次发生 Mixed GC 之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生 Mixed GC。")])])])]),e._v(" "),_("h3",{attrs:{id:"mixedgc-相关参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mixedgc-相关参数"}},[e._v("#")]),e._v(" MixedGC 相关参数")]),e._v(" "),_("ul",[_("li",[_("p",[_("code",[e._v("G1MixedGCLiveThresholdPercent")])]),e._v(" "),_("p",[e._v("Old 区的 region 被回收时候的存活对象占比")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("G1MixedGCCountTarget")])]),e._v(" "),_("p",[e._v("一次 global concurrent marking 之后，最多执行 Mixed GC 的次数")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("G1OldCSetRegionThresholdPercent")])]),e._v(" "),_("p",[e._v("一次 Mixed GC 中能被选入 CSet 的最多 old 区的 region 数量")])])]),e._v(" "),_("h3",{attrs:{id:"常用参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用参数"}},[e._v("#")]),e._v(" 常用参数")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-XX:+UseG1GC")]),e._v("：开启 G1")]),e._v(" "),_("li",[_("code",[e._v("-XX:G1HeapRegionSize=n")]),e._v("：region 的大小，1-32M，最多 2048 个")]),e._v(" "),_("li",[_("code",[e._v("-XX:MaxGCPauseMillis=200")]),e._v("：最大停顿时间")]),e._v(" "),_("li",[_("code",[e._v("-XX:G1NewSizePercent")])]),e._v(" "),_("li",[_("code",[e._v("-XX:G1MaxNewSizePercent")])]),e._v(" "),_("li",[_("code",[e._v("-XX:G1ReservePercent=10")]),e._v(" ：保留防止 to space 溢出，默认是百分之 10")]),e._v(" "),_("li",[_("code",[e._v("-XX:ParallelGCThreads=n")]),e._v(" ：SWT 线程数")]),e._v(" "),_("li",[_("code",[e._v("-XX:ConcGCThreads=n")]),e._v(" ：并发线程数= "),_("code",[e._v("1/4*并行")])])]),e._v(" "),_("h3",{attrs:{id:"最佳实践"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#最佳实践"}},[e._v("#")]),e._v(" 最佳实践")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("年轻代大小：")]),e._v(" "),_("p",[e._v("避免使用 "),_("code",[e._v("-Xmn")]),e._v("、"),_("code",[e._v("-XX:NewRatio")]),e._v(" 等显示设置 Young 区大小，会覆盖暂停时间目标")])]),e._v(" "),_("li",[_("p",[e._v("暂停时间目标：")]),e._v(" "),_("p",[e._v("暂停时间不要太严苛，其吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间，太严苛会直接影响到吞吐量")])])]),e._v(" "),_("p",[e._v("MixGC 调优：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("-XX:InitiatingHeapOccupancyPercent")])]),e._v(" "),_("li",[_("code",[e._v("-XX:G1MixedGCLiveThresholdPercent")]),e._v("、"),_("code",[e._v("-XX:G1HeapWastePercent")])]),e._v(" "),_("li",[_("code",[e._v("-XX:G1MixedGCCountTarget")])]),e._v(" "),_("li",[_("code",[e._v("-XX:G1OldCSetRegionThresholdPercent")])])]),e._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),_("p",[e._v("本章笔者是第一次接触，看得有点懵逼，记录也只是硬着头皮记录下来，某些并没有看懂")]),e._v(" "),_("p",[e._v("后续有此需求，还是需要去阅读官方文档的调优指南来理解。")])]),e._v(" "),_("h3",{attrs:{id:"是否需要切换到-g1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#是否需要切换到-g1"}},[e._v("#")]),e._v(" 是否需要切换到 G1")]),e._v(" "),_("ul",[_("li",[e._v("50% 以上的堆被存活对象占用")]),e._v(" "),_("li",[e._v("对象分配和晋升的速度变化非常大")]),e._v(" "),_("li",[e._v("垃圾回收时间特别长，超过了 1 秒")])])])}),[],!1,null,null,null);v.default=t.exports}}]);